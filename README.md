# android ndk 的使用方法 

## hello-jni 

本示例来自于$NDK_ROOT/sample 一个最简单的jni程序，由java程序调用c 程序 ,c函数的命名规范，依照java虚拟机的默认方式，也可以称为静态方式

编译
	cd hello-jni
	$NDK-ROOT/ndk-build

本示例没有包含头文件声明，其命名规范是依照JAVA虚拟机的默认函数调用方式 Java_package_class_methnod （都以下划线的方式链接). 例如当前className及本地方法分别为 com.example.hellojni 
及 stringFromJNI 则c语言的方法应写成如下
	
	Java_com_example_hellojni_HelloJni_stringFromJNI

我们也可以使用javah 命令生成头文件，然后根据头文件来写c语言的实现。 javah需要跟进已有的类生成c语言头文件。假设编译完的class存放在 hello-jni/bin/classes中。执行下面的命令生成头文件.

	cd hello-jni/bin/classes
	javah -classpath . -jni com.example.hellojni.HelloJni	
	
生成的头文件如下：
	
	/* DO NOT EDIT THIS FILE - it is machine generated */
	#include <jni.h>
	/* Header for class com_example_hellojni_HelloJni */
	
	#ifndef _Included_com_example_hellojni_HelloJni
	#define _Included_com_example_hellojni_HelloJni
	#ifdef __cplusplus
	extern "C" {
	#endif
	/*
	 * Class:     com_example_hellojni_HelloJni
	 * Method:    stringFromJNI
	 * Signature: ()Ljava/lang/String;
	 */
	JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_stringFromJNI
	  (JNIEnv *, jobject);
	
	/*
	 * Class:     com_example_hellojni_HelloJni
	 * Method:    unimplementedStringFromJNI
	 * Signature: ()Ljava/lang/String;
	 */
	JNIEXPORT jstring JNICALL Java_com_example_hellojni_HelloJni_unimplementedStringFromJNI
	  (JNIEnv *, jobject);
	
	#ifdef __cplusplus
	}
	#endif
	#endif

	
### c/c++ 调用java方法
c++ 调用java类的方法，很像以反射的方法调用类方法。其示例代码如下：

	jclass class =  (*env)->FindClass(env,"com/example/hellojni/HelloJni");
	jmethodID  method = (*env)->GetMethodID(env,class, "callMeFromJni","()V");
	(*env)->CallVoidMethod(env,thiz, method);

GetMethodID方法最后一个参数为“()V"为方法签名，主要用来区分重载方法。我们可以通过javap 命令显示 java方法的签名

	cd hello-jni/bin/classes
	javap -classpath . -s com.example.hellojni.HelloJni


## hello-jni2 

本示例在原版本做了些改进，主要是在于java调用c++ 代码的时候我们采用了动态注册的方式，避免了采用又长又丑的本地方法名称，最重要的是避免了c++ 的方法和java名字空间的直接依赖。你可以看到本地c++方法名称做了下面的改变。

	Java_com_example_hellojni_HelloJni_stringFromJNI => stringFromJNI


## two-share-lib

演示了在jni调用过程中依赖多个.so的情况
